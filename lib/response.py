import json
import logging
from enum import Enum

from lib.queue import queue_job
from lib.sent_tracking import UserSentTracking

logger = logging.getLogger(__name__)


class SenderTypes(Enum):
    FACEBOOK = 'facebook'
    TEST = 'test'


class Replyable(dict):
    def __init__(self, event: dict, type: SenderTypes):
        super().__init__(event)

        if type not in SenderTypes:
            raise ValueError(f'invalid type: {type}')

        self.type = type

    def send_text(self, text, quick_replies=None):
        """
        Sends a text message to a recipient, optionally with quick replies
        :param text: The text to be sent
        :param quick_replies: A list of quick replies (optional)
        """

        prefix = ''
        max_len = 640

        while len(text) > max_len:
            max_len = 630

            split_at = text.rfind(' ', 0, max_len)
            part = text[:split_at or 630]

            self.send_text(prefix + part + '...')

            prefix = '...'
            text = text[split_at or 630:]

        message = {'text': prefix + text}

        # Facebook does not allow empty lists of quick replies
        if quick_replies:
            message['quick_replies'] = quick_replies

        payload = {
            'message': message,
        }

        self.send(payload)

    def send_buttons(self, text, buttons):
        """
        Sends a text message with up to 3 buttons to a recipient
        :param text: The text to be sent (max. 640 characters)
        :param buttons: Up to 3 buttons
        """

        prefix = ''
        max_len = 640

        while len(text) > max_len:
            max_len = 630

            split_at = text.rfind(' ', 0, max_len)
            part = text[:split_at or 630]

            self.send_text(prefix + part + '...')

            prefix = '...'
            text = text[split_at or 630:]

        payload = {
            'message': {
                'attachment': {
                    'type': 'template',
                    'payload': {
                        'template_type': 'button',
                        'text': prefix + text,
                        'buttons': buttons
                    }
                }
            }
        }

        self.send(payload)

    def send_generic(self, elements):
        """
        Sends a generic template with up to 10 elements to a recipient
        :param elements: Up to 10 elements
        """

        payload = {
            'message': {
                'attachment': {
                    'type': 'template',
                    'payload': {
                        'template_type': 'generic',
                        'elements': elements
                    }
                }
            }
        }

        self.send(payload)

    def send_list(self, elements, top_element_style='compact', button=None):
        """
        Sends a list template to the recipient
        :param elements: A list of 2-4 elements generated by list_element
        :param top_element_style: Can be either 'large' or 'compact'
        :param button: Optional button_postback to show at the end of the list
        :return:
        """
        payload = {
            "message": {
                "attachment": {
                    "type": "template",
                    "payload": {
                        "template_type": "list",
                        "top_element_style": top_element_style,
                        "elements": elements,
                        "buttons": [
                            button
                        ]
                    }
                }
            }
        }

        if not button:
            payload['message']['attachment']['payload'].pop('buttons')

        self.send(payload)

    def send_attachment(self, url, type=None):
        """
        Send an attachment by URL. If the URL has not been uploaded before, it will be uploaded and the
        attachment ID will be saved to the database. If the URL has been uploaded before, the ID is
        fetched from the database. Then, the attachment is sent by ID.
        :param url: The URL of the attachment
        :param type: Type of the attachment. If not defined, guess_attachment_type is used
        """
        if self.type != SenderTypes.FACEBOOK:
            raise NotImplementedError("Sending attachments to non-Facebook users is not possible yet.")

        queue_job('fb.SendAttachment',
                  {'recipient_id': self['sender']['id'], 'url': url, 'type': type})

    def send_attachment_by_id(self, attachment_id, type):
        """
        Sends an attachment via ID
        :param attachment_id: The attachment ID returned by upload_attachment
        :param type: The attachment type (see guess_attachment_type)
        """

        # create a media object
        media = {'attachment_id': attachment_id}

        # add the image object to an attachment of type "image"
        attachment = {
            'type': type,
            'payload': media
        }

        # add the attachment to a message instead of "text"
        message = {'attachment': attachment}

        # now create the final payload with the recipient
        payload = {
            'message': message
        }
        self.send(payload)

    def send(self, payload):
        """Queues a payload on the correct worker queue"""
        logger.debug("JSON Payload: " + json.dumps(payload))

        sending_id = UserSentTracking.inc_queued(self['sender']['id'])
        if self.type == SenderTypes.FACEBOOK:
            payload['recipient'] = {
                'id': self['sender']['id'],
            }

            queue_job('fb.Send', {'payload': payload, 'sending_id': sending_id})


def list_element(title, subtitle=None, image_url=None, buttons=None, default_action=None):
    """
    Creates a dict to use with send_list
    :param title: Element title
    :param subtitle: Element subtitle (optional)
    :param image_url: Element image URL (optional)
    :param buttons: List of button_postback to show under the element (optional)
    :param default_action: Action generated by button_url (optional)
    :return: dict
    """
    payload = {
        "title": title,
        "image_url": image_url,
        "subtitle": subtitle,
        "default_action": default_action,
        "buttons": buttons
    }

    if not subtitle:
        payload.pop('subtitle')

    if not image_url:
        payload.pop('image_url')

    if not buttons:
        payload.pop('buttons')

    if not default_action:
        payload.pop('default_action')

    return payload

def button_postback(title, payload):
    """
    Creates a dict to use with send_buttons
    :param title: Button title
    :param payload: Button payload
    :return: dict
    """
    if isinstance(payload, (dict, list)):
        payload = json.dumps(payload)

    return {
        'type': 'postback',
        'title': title,
        'payload': payload,
    }

def button_web_url(title, url):
    """
    Creates a dict to send a web_url, can be used with generic_elements or send_buttons
    :param title: Content to show the receiver
    :return: dict
    """
    return {
        'type': 'web_url',
        'url': url,
        'title': title
    }

def button_share(generic_element):
    """
    Creates a dict to send a web_url, can be used with generic_elements or send_buttons
    :param title: Content to show the receiver
    :return: dict
    """
    button = {
        'type': 'element_share',
        'share_contents': {
            'attachment': {
                'type': 'template',
                'payload': {
                    'template_type': 'generic',
                    'elements': generic_element
                }
            }
        }
    }

    if not generic_element:
        button.pop('share_contents')

    return button

def generic_element(title, subtitle=None, image_url=None, buttons=None):
    """
    Creates a dict to use with send_generic
    :param title: Content for receiver title
    :param subtitle: Content for receiver subtitle (optional)
    :param image_url: Content for receiver image to show by url (optional)
    :param button: Content for receiver button shown (optional)
    :return: dict
    """
    element = {
        "title": title,
        "subtitle": subtitle,
        "image_url": image_url,
        "buttons": buttons
    }

    if not subtitle:
        element.pop('subtitle')

    if not image_url:
        element.pop('image_url')

    if not buttons:
        element.pop('buttons')

    return element

def button_url(title, url, webview_height_ratio='full'):
    """
    Creates a dict to use with send_buttons
    :param title: Button title
    :param url: Button URL
    :param webview_height_ratio: Height of the Webview. Valid values: compact, tall, full.
    :return: dict
    """
    return {
        'type': 'web_url',
        'title': title,
        'url': url,
        'webview_height_ratio': webview_height_ratio
    }

def quick_reply(title, payload, image_url=None):
    """
    Creates a dict to use with send_text
    :param title: The title of the quick reply
    :param payload: The payload
    :param image_url: The image url (optional)
    :return: dict
    """
    if isinstance(payload, (dict, list)):
        payload = json.dumps(payload)

    payload_ = {
        'content_type': 'text',
        'title': title,
        'payload': payload,
      }

    if image_url:
        payload_['image_url'] = image_url

    return payload_
